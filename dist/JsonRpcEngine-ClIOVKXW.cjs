"use strict";var D=(s,u,r)=>{if(!u.has(s))throw TypeError("Cannot "+r)};var w=(s,u,r)=>(D(s,u,"read from private field"),r?r.call(s):u.get(s)),p=(s,u,r)=>{if(u.has(s))throw TypeError("Cannot add the same private member more than once");u instanceof WeakSet?u.add(s):u.set(s,r)},v=(s,u,r,t)=>(D(s,u,"write to private field"),t?t.call(s,r):u.set(s,r),r);var a=(s,u,r)=>(D(s,u,"access private method"),r);const c=require("./classes-6zjC54GF.cjs"),Q=require("./safeEventEmitter.cjs"),A=require("./versions-CznKZ0ZU.cjs"),F=4294967295;let S=Math.floor(Math.random()*F);function G(){return S=(S+1)%F,S}function V(){return(s,u,r,t)=>{const e=s.id,n=G();s.id=n,u.id=n,r(i=>{s.id=e,u.id=e,i()})}}const W="This engine is destroyed and can no longer be used.";var C,m,l,E,I,M,O,g,z,P,X,j,T,$,Y,R,J,H,K;const h=class h extends Q{constructor({notificationHandler:r}={}){super();p(this,E);p(this,M);p(this,g);p(this,C,!1);p(this,m,void 0);p(this,l,void 0);v(this,m,[]),v(this,l,r)}destroy(){w(this,m).forEach(r=>{"destroy"in r&&typeof r.destroy=="function"&&r.destroy()}),v(this,m,[]),v(this,C,!0)}push(r){a(this,E,I).call(this),w(this,m).push(r)}handle(r,t){if(a(this,E,I).call(this),t&&typeof t!="function")throw new Error('"callback" must be a function if provided.');return Array.isArray(r)?t?a(this,M,O).call(this,r,t):a(this,M,O).call(this,r):t?a(this,g,z).call(this,r,t):this._promiseHandle(r)}asMiddleware(){return a(this,E,I).call(this),async(r,t,e,n)=>{var i,d;try{const[o,f,y]=await a(i=h,j,T).call(i,r,t,w(this,m));return f?(await a(d=h,R,J).call(d,y),n(o)):e(async U=>{var B;try{await a(B=h,R,J).call(B,y)}catch(L){return U(L)}return U()})}catch(o){return n(o)}}}async _promiseHandle(r){return new Promise((t,e)=>{a(this,g,z).call(this,r,(n,i)=>{n&&i===void 0?e(n):t(i)}).catch(e)})}};C=new WeakMap,m=new WeakMap,l=new WeakMap,E=new WeakSet,I=function(){if(w(this,C))throw new Error(W)},M=new WeakSet,O=async function(r,t){try{if(r.length===0){const n=[{id:null,jsonrpc:"2.0",error:new c.JsonRpcError(c.errorCodes.rpc.invalidRequest,"Request batch must contain plain objects. Received an empty array")}];return t?t(null,n):n}const e=(await Promise.all(r.map(this._promiseHandle.bind(this)))).filter(n=>n!==void 0);return t?t(null,e):e}catch(e){if(t)return t(e);throw e}},g=new WeakSet,z=async function(r,t){var d;if(!r||Array.isArray(r)||typeof r!="object"){const o=new c.JsonRpcError(c.errorCodes.rpc.invalidRequest,`Requests must be plain objects. Received: ${typeof r}`,{request:r});return t(o,{id:null,jsonrpc:"2.0",error:o})}if(typeof r.method!="string"){const o=new c.JsonRpcError(c.errorCodes.rpc.invalidRequest,`Must specify a string method. Received: ${typeof r.method}`,{request:r});return w(this,l)&&!A.isJsonRpcRequest(r)?t(null):t(o,{id:r.id??null,jsonrpc:"2.0",error:o})}if(w(this,l)&&!A.isJsonRpcRequest(r)){try{await w(this,l).call(this,r)}catch(o){return t(o)}return t(null)}let e=null;const n={...r},i={id:n.id,jsonrpc:n.jsonrpc};try{await a(d=h,P,X).call(d,n,i,w(this,m))}catch(o){e=o}return e&&(delete i.result,i.error||(i.error=c.serializeError(e))),t(e,i)},P=new WeakSet,X=async function(r,t,e){var o,f,y;const[n,i,d]=await a(o=h,j,T).call(o,r,t,e);if(a(f=h,H,K).call(f,r,t,i),await a(y=h,R,J).call(y,d),n)throw n},j=new WeakSet,T=async function(r,t,e){var o;const n=[];let i=null,d=!1;for(const f of e)if([i,d]=await a(o=h,$,Y).call(o,r,t,f,n),d)break;return[i,d,n.reverse()]},$=new WeakSet,Y=async function(r,t,e,n){return new Promise(i=>{const d=f=>{const y=f||t.error;y&&(t.error=c.serializeError(y)),i([y,!0])},o=f=>{t.error?d(t.error):(f&&(typeof f!="function"&&d(new c.JsonRpcError(c.errorCodes.rpc.internal,`JsonRpcEngine: "next" return handlers must be functions. Received "${typeof f}" for request:
${x(r)}`,{request:r})),n.push(f)),i([null,!1]))};try{e(r,t,o,d)}catch(f){d(f)}})},R=new WeakSet,J=async function(r){for(const t of r)await new Promise((e,n)=>{t(i=>i?n(i):e())})},H=new WeakSet,K=function(r,t,e){if(!A.hasProperty(t,"result")&&!A.hasProperty(t,"error"))throw new c.JsonRpcError(c.errorCodes.rpc.internal,`JsonRpcEngine: Response has no error or result for request:
${x(r)}`,{request:r});if(!e)throw new c.JsonRpcError(c.errorCodes.rpc.internal,`JsonRpcEngine: Nothing ended request:
${x(r)}`,{request:r})},p(h,P),p(h,j),p(h,$),p(h,R),p(h,H);let N=h;function x(s){return JSON.stringify(s,null,2)}exports.JsonRpcEngine=N;exports.createIdRemapMiddleware=V;exports.getUniqueId=G;
